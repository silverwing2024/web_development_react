# 금일 수업 계획
## useMemo 관련 실습
### useEffect 관련 실습
```jsx
import { useState, useEffect, useMemo } from "react";
import './App.css'

function App(){
  const [number, setNumber] = useState(0);
  const [isTrue, setIsTrue] = useState(true);
  
  const answer = isTrue? "true" : "false";

  //answer가 바뀔 때만 콘솔이 찍히도록 useEffect 적용
  useEffect(() => {
    console.log('answer 값이 변경되었습니다.');
  }, []); //빈 배열은 처음렌더링 될 때만 저장한다는 의미. 

  return(
    <div>
      <p>number</p>
      <input 
      type="number"
      value={number}
      onChange={(e)=>setNumber(e.target.value)} 
      />
      <hr />
      <p>answer</p>
      <p>True or False? {answer}</p>
      <button onClick={(e) => setIsTrue(!isTrue)}>Reverse</button>

    </div>
  );
}

export default App;
```

```jsx
useEffect(() => {
    console.log('최초 렌더링 시에만 실행됩니다.(strictmode라면 두 번 실행됩니다)');
  }, []); 
```

  - 의존 성 배열에 아무런 값이 없는 경우: 최초 렌더링 시에 useEffect 내의 콜백 함수가 실행됨(즉, 한번만 실행됨(refresh))

```jsx
useEffect(() => {
    console.log('answer 값이 변경되었습니다.');
  }, [answer]);
```
- isTrue의 값이 변경될 때 마다 useEffect() 내의 콜백 함수가 실행됨 -> 버튼 누를 때 마다 console.log가 찍힘

```jsx
useEffect(() => {
    console.log('number 값이 변경되었습니다.');
  }, [number]);
```
- input 창에 숫자를 입력할 때 마다(왜? e.targer.value를 통해서 onChange로 감지하기 때문에) console.log가 찍힘

```jsx
useEffect(() => {
    console.log('number 또는 answer 값이 변경되었습니다.');
  }, [number, answer]); 
```
-input에 값을 입력하거나 혹은 버튼을 누를 때 전부 console.log가 찍히게 됨.

현재 primitive type 기초 자료형인 answer(bool)을 객체 타입으로 만들어줘 보겠습니다. 

```jsx
import { useState, useEffect, useMemo } from "react";
import './App.css'

function App(){
  const [number, setNumber] = useState(0);
  const [isTrue, setIsTrue] = useState(true);
  
  // const answer = isTrue? "true" : "false"; 기초자료형(primitive)

  const answer = {bool: isTrue ? "true" : "false"};

  //answer가 바뀔 때만 콘솔이 찍히도록 useEffect 적용
  useEffect(() => {
    console.log('answer 값이 변경되었습니다.');
  }, [answer]); //빈 배열은 처음렌더링 될 때만 저장한다는 의미. 

  return(
    <div>
      <p>number</p>
      <input 
      type="number"
      value={number}
      onChange={(e)=>setNumber(e.target.value)} 
      />
      <hr />
      <p>answer</p>
      {/* <p>True or False? {answer}</p> */}
      <p>True or False? {answer['bool']}</p>
      <button onClick={(e) => setIsTrue(!isTrue)}>Reverse</button>

    </div>
  );
}

export default App;
```

-  이상과 같이 수정했을 경우 number만 변경했을 때에도 (즉 input창에 숫자를 입력했는데) 콘솔이 출력되고 있었습니다. 
-> 그러면 좀 이상한게 의존성 배열이 [answer]였는데도 console.log가 출력되고 있었으니까
-> isTrue 의 값이 숫자를 입력할 때 마다 true <-> false를 왔다갔다 하고 있다는 것을 의미합니다. 

이상과 같은 동작이 발생하는 이유: 
- number를 변경해서 컴포넌트가 리렌더링 되면 함수형 컴포넌트인 App안에 있는 변수들이 모두 초기화되어서 다시 할당되기 때문에 객체 타입인 answer가 다시 할당됩니다. 

그런데 객체 타입은 그 변수에 직접 저장되는 것이 아니라, 메모리 주소값이 할당되어 그 값을 참조하게 됩니다. 따라서 컴포넌트가 리렌더링되면 객체는 다른 메모리에 할당되고, 변수는 그에 맞는 달라진 주소값이 할당되게 됩니다. useEffect는 렌더링 전과 후의 answer 주소값이 다르다고 판단하여 console.log를 출력하게 됩니다. 

- 즉, 사실 true <-> false가 변하는게 아니라, 메모리 주소값의 변경으로 인해서 발생한겁니다. 

```jsx
  const answer = useMemo(()=> {
    return{bool: isTrue? "true" : "false"};
  },[isTrue]);
```
- 이상과 같이 코드를 작성할 경우(useMemo() 함수의 결과값을 answer에 담았을 경우), 최초의 렌더링 될 때 객체의 주소값을 answer 상수가 메모이제이션합니다. 이 후 리렌더링부터는 메모이제이션된 주소값을 재사용하게 됩니다. 따라서 반복적으로 리런더링되더라도 useEffect에 작성한 console.log는 찍히지 않게 됩니다. 

### 정리 :
- useMemo는 메모이제이션으로 수행한 연산의 결과값을 기억함으로써 불필요한 계산을 최소화하고, 리렌더링을 막습니다. 


## JS toDoList vs. React toDoList

web_development_js / chapter13_locastorage를 확인하시면 JS version toDoList를 확인할 수 있습니다. 

npm create vite@4.3
reacttodoapp
react
JavaScript

## useEffect() 코인 현재 가격 추적기
